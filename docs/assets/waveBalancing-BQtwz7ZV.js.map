{"version":3,"file":"waveBalancing-BQtwz7ZV.js","sources":["../../Z_TD/src/config/waveBalancing.ts"],"sourcesContent":["/**\n * Wave Balancing System\n *\n * This system calculates wave difficulty based on player progression and tower DPS.\n * It provides formulas to balance zombie health, count, and spawn rates.\n */\n\nimport { TowerConstants } from './towerConstants';\n\nexport interface WaveBalanceConfig {\n  // Base difficulty settings\n  baseZombieHealth: number;\n  baseZombieCount: number;\n  baseSpawnInterval: number; // milliseconds between spawns\n\n  // Scaling factors per wave\n  healthScaling: number; // Multiplier per wave (e.g., 1.15 = 15% increase per wave)\n  countScaling: number; // Additional zombies per wave\n  spawnRateScaling: number; // Spawn rate multiplier per wave\n\n  // Player progression assumptions\n  expectedTowersPerWave: number; // How many towers player should have by wave X\n  expectedUpgradeLevelPerWave: number; // Average upgrade level by wave X\n\n  // Difficulty curve\n  difficultyMultiplier: number; // Overall difficulty (1.0 = normal, 1.5 = hard)\n}\n\nexport const WaveBalancing = {\n  // Default balance configuration\n  config: {\n    baseZombieHealth: 100,\n    baseZombieCount: 5,\n    baseSpawnInterval: 2000, // 2 seconds\n\n    healthScaling: 1.2, // 20% more health per wave\n    countScaling: 2, // 2 more zombies per wave\n    spawnRateScaling: 0.95, // 5% faster spawns per wave\n\n    expectedTowersPerWave: 0.5, // Player gains ~1 tower every 2 waves\n    expectedUpgradeLevelPerWave: 0.3, // Player upgrades ~1 level every 3 waves\n\n    difficultyMultiplier: 1.0,\n  } as WaveBalanceConfig,\n\n  /**\n   * Calculate expected player DPS for a given wave\n   * This helps us know how much damage the player should be dealing\n   */\n  calculateExpectedPlayerDPS(wave: number): number {\n    const config = this.config;\n\n    // Estimate number of towers player has\n    const towerCount = Math.floor(1 + wave * config.expectedTowersPerWave);\n\n    // Estimate average upgrade level\n    const avgUpgradeLevel = Math.floor(wave * config.expectedUpgradeLevelPerWave);\n\n    // Use machine gun as baseline tower (most common)\n    const baseDamage = TowerConstants.MACHINE_GUN.damage;\n    const baseFireRate = TowerConstants.MACHINE_GUN.fireRate;\n\n    // Calculate damage with upgrades (+50% per level)\n    const upgradedDamage = baseDamage * (1 + avgUpgradeLevel * 0.5);\n\n    // Total DPS = towers × damage × fire rate\n    const totalDPS = towerCount * upgradedDamage * baseFireRate;\n\n    return totalDPS;\n  },\n\n  /**\n   * Calculate zombie health for a given wave\n   * Balanced so zombies take reasonable time to kill\n   */\n  calculateZombieHealth(\n    wave: number,\n    zombieType: 'basic' | 'fast' | 'tank' | 'armored' | 'swarm' | 'stealth' | 'mechanical' = 'basic'\n  ): number {\n    const config = this.config;\n\n    // Base health scales exponentially with wave\n    const baseHealth = config.baseZombieHealth * Math.pow(config.healthScaling, wave - 1);\n\n    // Type multipliers\n    const typeMultipliers = {\n      basic: 1.0,\n      fast: 0.6, // Less health, more speed\n      tank: 4.0, // Massive health\n      armored: 2.5, // Heavy armor\n      swarm: 0.4, // Very weak\n      stealth: 1.2, // Slightly more health\n      mechanical: 2.0, // Tough\n    };\n\n    const health = baseHealth * typeMultipliers[zombieType] * config.difficultyMultiplier;\n\n    return Math.floor(health);\n  },\n\n  /**\n   * Calculate zombie count for a given wave\n   * Ensures waves feel progressively harder\n   */\n  calculateZombieCount(wave: number): number {\n    const config = this.config;\n\n    // Linear + exponential growth\n    const linearGrowth = config.baseZombieCount + (wave - 1) * config.countScaling;\n    const exponentialBonus = Math.floor(wave / 5) * 2; // +2 zombies every 5 waves\n\n    const count = linearGrowth + exponentialBonus;\n\n    return Math.floor(count * config.difficultyMultiplier);\n  },\n\n  /**\n   * Calculate spawn interval for a given wave\n   * Zombies spawn faster in later waves\n   */\n  calculateSpawnInterval(wave: number): number {\n    const config = this.config;\n\n    // Spawn rate increases each wave\n    const interval = config.baseSpawnInterval * Math.pow(config.spawnRateScaling, wave - 1);\n\n    // Minimum spawn interval (don't go too fast)\n    const minInterval = 500; // 0.5 seconds minimum\n\n    return Math.max(minInterval, Math.floor(interval));\n  },\n\n  /**\n   * Calculate wave duration (how long the wave should last)\n   */\n  calculateWaveDuration(wave: number): number {\n    const count = this.calculateZombieCount(wave);\n    const interval = this.calculateSpawnInterval(wave);\n\n    // Time to spawn all zombies + buffer for last zombie to reach end\n    const spawnTime = count * interval;\n    const travelTime = 15000; // ~15 seconds for zombie to traverse map\n\n    return spawnTime + travelTime;\n  },\n\n  /**\n   * Calculate recommended money reward for completing a wave\n   */\n  calculateWaveReward(wave: number): number {\n    // Base reward + scaling\n    const baseReward = 50;\n    const scaling = 10; // +10 per wave\n\n    return baseReward + wave * scaling;\n  },\n\n  /**\n   * Calculate total zombie HP in a wave\n   * Useful for balancing against player DPS\n   */\n  calculateTotalWaveHP(wave: number): number {\n    const count = this.calculateZombieCount(wave);\n    const health = this.calculateZombieHealth(wave, 'basic');\n\n    return count * health;\n  },\n\n  /**\n   * Calculate time to kill wave (theoretical)\n   * Helps validate if wave is beatable\n   */\n  calculateTimeToKillWave(wave: number): number {\n    const totalHP = this.calculateTotalWaveHP(wave);\n    const playerDPS = this.calculateExpectedPlayerDPS(wave);\n\n    // Time in seconds\n    return totalHP / playerDPS;\n  },\n\n  /**\n   * Validate wave balance\n   * Returns warnings if wave seems unbalanced\n   */\n  validateWaveBalance(wave: number): string[] {\n    const warnings: string[] = [];\n\n    const timeToKill = this.calculateTimeToKillWave(wave);\n    const waveDuration = this.calculateWaveDuration(wave) / 1000; // Convert to seconds\n\n    // Check if player has enough time to kill all zombies\n    if (timeToKill > waveDuration * 0.9) {\n      warnings.push(\n        `⚠️ Wave ${wave}: Very tight! Time to kill (${timeToKill.toFixed(1)}s) is close to wave duration (${waveDuration.toFixed(1)}s)`\n      );\n    }\n\n    if (timeToKill > waveDuration) {\n      warnings.push(\n        `❌ Wave ${wave}: IMPOSSIBLE! Time to kill (${timeToKill.toFixed(1)}s) exceeds wave duration (${waveDuration.toFixed(1)}s)`\n      );\n    }\n\n    // Check if wave is too easy\n    if (timeToKill < waveDuration * 0.3) {\n      warnings.push(\n        `ℹ️ Wave ${wave}: Too easy? Time to kill (${timeToKill.toFixed(1)}s) is much less than wave duration (${waveDuration.toFixed(1)}s)`\n      );\n    }\n\n    return warnings;\n  },\n\n  /**\n   * Generate a balance report for multiple waves\n   */\n  generateBalanceReport(startWave: number = 1, endWave: number = 10): string {\n    let report = '=== WAVE BALANCE REPORT ===\\n\\n';\n\n    for (let wave = startWave; wave <= endWave; wave++) {\n      const zombieCount = this.calculateZombieCount(wave);\n      const zombieHealth = this.calculateZombieHealth(wave);\n      const totalHP = this.calculateTotalWaveHP(wave);\n      const playerDPS = this.calculateExpectedPlayerDPS(wave);\n      const timeToKill = this.calculateTimeToKillWave(wave);\n      const waveDuration = this.calculateWaveDuration(wave) / 1000;\n      const spawnInterval = this.calculateSpawnInterval(wave);\n      const reward = this.calculateWaveReward(wave);\n\n      report += `Wave ${wave}:\\n`;\n      report += `  Zombies: ${zombieCount} × ${zombieHealth}hp = ${totalHP} total HP\\n`;\n      report += `  Spawn Interval: ${spawnInterval}ms\\n`;\n      report += `  Expected Player DPS: ${playerDPS.toFixed(1)}\\n`;\n      report += `  Time to Kill: ${timeToKill.toFixed(1)}s / ${waveDuration.toFixed(1)}s (${((timeToKill / waveDuration) * 100).toFixed(1)}%)\\n`;\n      report += `  Reward: $${reward}\\n`;\n\n      const warnings = this.validateWaveBalance(wave);\n      if (warnings.length > 0) {\n        report += `  ${warnings.join('\\n  ')}\\n`;\n      }\n\n      report += '\\n';\n    }\n\n    return report;\n  },\n\n  /**\n   * Update balance configuration\n   */\n  updateConfig(newConfig: Partial<WaveBalanceConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  },\n\n  /**\n   * Reset to default configuration\n   */\n  resetConfig(): void {\n    this.config = {\n      baseZombieHealth: 100,\n      baseZombieCount: 5,\n      baseSpawnInterval: 2000,\n      healthScaling: 1.2,\n      countScaling: 2,\n      spawnRateScaling: 0.95,\n      expectedTowersPerWave: 0.5,\n      expectedUpgradeLevelPerWave: 0.3,\n      difficultyMultiplier: 1.0,\n    };\n  },\n};\n\n// Export helper function for console testing\nexport function printWaveBalance(startWave: number = 1, endWave: number = 10): void {\n  console.log(WaveBalancing.generateBalanceReport(startWave, endWave));\n}\n"],"names":["WaveBalancing","wave","config","towerCount","avgUpgradeLevel","baseDamage","TowerConstants","baseFireRate","upgradedDamage","zombieType","health","linearGrowth","exponentialBonus","count","interval","totalHP","playerDPS","warnings","timeToKill","waveDuration","startWave","endWave","report","zombieCount","zombieHealth","spawnInterval","reward","newConfig","printWaveBalance"],"mappings":"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"}